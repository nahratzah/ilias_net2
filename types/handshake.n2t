/*
 * Copyright (c) 2012 Ariane van der Steldt <ariane@stack.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <stdint.h>
#include <ilias/net2/ilias_net2_export.h>
#include <ilias/net2/types.h>
#include "signature.h"


/*
 * Key exchange with optional host signature.
 */
struct key_exchange {
	struct net2_buffer	*payload;
	struct net2_signature	 signature;
};


/*
 * Negotiation packets.
 *
 * These are kept small, so they won't span multiple packets during
 * transmission: the conn_negotiator has no way of making a message cross
 * a boundary.
 *
 * Headers may only be coded using net2_proto at version 0.
 * Otherwise, future extensions may break backwards compatibility during
 * the negotiation stage, making it impossible to achieve a connection.
 */
struct header {
	uint32_t		 flags;
#define F_TYPEMASK		 0x00000fffU
#define F_TYPE_PVER		 0x00000000U
#define F_TYPE_XCHANGE		(0x00000000U | F_SET_ELEMENT)
#define F_TYPE_HASH		(0x00000001U | F_SET_ELEMENT)
#define F_TYPE_CRYPT		(0x00000002U | F_SET_ELEMENT)
#define F_TYPE_SIGN		(0x00000003U | F_SET_ELEMENT)
#define F_SET_ELEMENT		 0x00000800U
#define F_SET_LASTELEM		 0x00001000U
#define F_SET_EMPTY		 0x00002000U
#define F_STRING		 0x00010000U

/*
 * Special key exchange bits.
 * Use the TYPEMASK to find out which key this is.
 * Use the sequence to find out which message sequence this is.
 */
#define F_XCHANGE		 0x10000000U
#define F_XCHANGE_SIGNATURE	 0x20000000U
#define F_XCHANGE_HASH_TYPE	 0x00000000U
#define F_XCHANGE_ENC_TYPE	 0x00000001U

/* Indicates the end of a connection negotiation. */
#define F_LAST_HEADER		 0xffffffffU

	uint32_t		 fin_reserved;	/* Must be zero. */

	uint32_t		 seq;
	union {
		struct {
			net2_protocol_t
				 version;
			uint16_t num_types;
			uint16_t num_settypes;
			uint32_t options;
			uint32_t reserved;	/* Must be zero. */
		};
		char		*string;
		uint32_t	 val;
		struct key_exchange
				 key_exchange;
	}			 payload;
};


extern ILIAS_NET2_LOCAL
const struct header	header_fini;
/* Length of header_fini on the wire. */
#define FINI_LEN	4 /* bytes */


ILIAS_NET2_LOCAL
uint32_t mask_option(net2_protocol_t, uint32_t);
ILIAS_NET2_LOCAL
int	 header_flag_supported(net2_protocol_t, uint32_t);

ILIAS_NET2_LOCAL
int	 init_header_protocol(struct header*, uint32_t);
ILIAS_NET2_LOCAL int
init_header_val(struct header*, uint32_t, uint32_t);
ILIAS_NET2_LOCAL int
init_header_string(struct header*, const char*, uint32_t);
ILIAS_NET2_LOCAL
int	 init_header_valset(struct header*, int, uint32_t, int,
	    uint32_t);
ILIAS_NET2_LOCAL
int	 init_header_stringset(struct header*, int, const char*, int,
	    uint32_t);
ILIAS_NET2_LOCAL
int	 init_header_empty_set(struct header*, uint32_t);
ILIAS_NET2_LOCAL
void	 deinit_header(struct header*);


%%
#include "handshake.h"
#include <stdlib.h>
#include <string.h>
#include <ilias/net2/ctypes.h>
%%


type header (
	ctype struct header,
	encode cp_header_encode,
	decode cp_header_decode,
	init cp_header_init,
	destroy cp_header_destroy
);


%%
/* Describe for each option which protocol version first supported it. */
static const net2_protocol_t	options[] = {
	/* ENCRYPTION */	 0,
	/* SIGNING */		 0,
};

/*
 * Describe for each header payload type at which protocol version it was
 * first supported.
 */
static const net2_protocol_t	header_flags[] = {
	/* PVER */		 0,
};
/*
 * Describe for each header set payload type at which protocol version it was
 * first supported.
 */
static const net2_protocol_t	header_set_flags[] = {
	/* XCHANGE */		 0,
	/* HASH */		 0,
	/* CRYPT */		 0,
	/* SIGN */		 0,
};


/*
 * Mask options to only include those supported at a given protocol version.
 */
ILIAS_NET2_LOCAL uint32_t
mask_option(net2_protocol_t pver, uint32_t option)
{
	unsigned int	i;
	uint32_t	supported;
#define NUM_OPTIONS	(sizeof(options) / sizeof(options[0]))

	/* Mark all supported options based on pver. */
	supported = 0;
	for (i = 0; i < NUM_OPTIONS; i++) {
		if (options[i] <= pver)
			supported |= (uint32_t)1 << i;
	}
#undef NUM_OPTIONS

	return option & supported;
}

/*
 * Test if a certain header flag is supported.
 */
ILIAS_NET2_LOCAL int
header_flag_supported(net2_protocol_t pver, uint32_t hflag)
{
	uint32_t	 type;
	const net2_protocol_t
			*collection;
	size_t		 coll_size;

	type = hflag & F_TYPEMASK;
	if (hflag & F_SET_ELEMENT) {
		collection = header_set_flags;
		coll_size = sizeof(header_set_flags) /
		    sizeof(header_set_flags[0]);
		type &= ~F_SET_ELEMENT;
	} else {
		collection = header_flags;
		coll_size = sizeof(header_flags) /
		    sizeof(header_flags[0]);
	}

	if (type >= coll_size)
		return 0;
	if (collection[type] > pver)
		return 0;
	return 1;
}


/* Create protocol header. */
ILIAS_NET2_LOCAL int
init_header_protocol(struct header *h, uint32_t flags)
{
	h->flags = F_TYPE_PVER;
	h->payload.version = net2_proto.version;
	h->payload.num_types =
	    sizeof(header_flags) / sizeof(header_flags[0]);
	h->payload.num_settypes =
	    sizeof(header_set_flags) / sizeof(header_set_flags[0]);
	h->payload.options = flags;
	h->payload.reserved = 0;
	return 0;
}
/* Describe value header. */
ILIAS_NET2_LOCAL int
init_header_val(struct header *h, uint32_t value, uint32_t which)
{
	if ((which & F_TYPEMASK) != which)
		return EINVAL;
	h->flags = which;

	if (h->flags & F_SET_ELEMENT)
		return EINVAL;
	h->payload.val = value;
	return 0;
}
/* Describe string header. */
ILIAS_NET2_LOCAL int
init_header_string(struct header *h, const char *value, uint32_t which)
{
	if ((which & F_TYPEMASK) != which)
		return EINVAL;
	h->flags = which;
	if (value == NULL)
		return EINVAL;

	if (h->flags & F_SET_ELEMENT)
		return EINVAL;
	if ((h->payload.string = strdup(value)) == NULL)
		return ENOMEM;
	h->flags |= F_STRING;
	return 0;
}
/* Create valset header. */
ILIAS_NET2_LOCAL int
init_header_valset(struct header *h, int seq, uint32_t value,
    int max_seq, uint32_t which)
{
	if ((which & F_TYPEMASK) != which)
		return EINVAL;
	h->flags = which;
	h->seq = seq;

	if (!(h->flags & F_SET_ELEMENT))
		return EINVAL;
	if (seq == max_seq)
		h->flags |= F_SET_LASTELEM;
	h->payload.val = value;
	return 0;
}
/* Create stringset header. */
ILIAS_NET2_LOCAL int
init_header_stringset(struct header *h, int seq, const char *value,
    int max_seq, uint32_t which)
{
	if ((which & F_TYPEMASK) != which)
		return EINVAL;
	h->flags = which;
	h->seq = seq;
	if (value == NULL)
		return EINVAL;

	if (!(h->flags & F_SET_ELEMENT))
		return EINVAL;
	if (seq == max_seq)
		h->flags |= F_SET_LASTELEM;
	if ((h->payload.string = strdup(value)) == NULL)
		return ENOMEM;
	h->flags |= F_STRING;
	return 0;
}
/* Create empty set. */
ILIAS_NET2_LOCAL int
init_header_empty_set(struct header *h, uint32_t which)
{
	if ((which & F_TYPEMASK) != which)
		return EINVAL;
	h->flags = which;
	h->flags |= F_SET_EMPTY;
	return 0;
}
/* Free resources of header. */
ILIAS_NET2_LOCAL void
deinit_header(struct header *h)
{
	if (h->flags == F_LAST_HEADER)
		return;
	if (h->flags & F_XCHANGE)
		net2_buffer_free(h->payload.key_exchange.payload);
	if (h->flags & F_XCHANGE_SIGNATURE)
		net2_signature_deinit(&h->payload.key_exchange.signature);
	if (h->flags & F_STRING)
		free(h->payload.string);
}

/* Encode header. */
static int
cp_header_encode(struct net2_encdec_ctx *proto_ctx, struct net2_buffer *out,
    const struct header *h, const void *arg)
{
	struct net2_encdec_ctx	 ctx;
	struct net2_pvlist	 pv;
	int			 error;

	/* Initialize ctx. */
	if ((error = net2_pvlist_init(&pv)) != 0)
		goto out_0;
	if ((error = net2_pvlist_add(&pv, &net2_proto, 0)) != 0)
		goto out_1;
	if ((error = net2_encdec_ctx_init(&ctx, NULL, NULL)) != 0)
		goto out_2;

	/* Encode flags. */
	if ((error = net2_cp_encode(&ctx, &cp_uint32, out, &h->flags,
	    NULL)) != 0)
		goto out_2;
	if (h->flags == F_LAST_HEADER) {
		error = net2_cp_encode(&ctx, &cp_uint32, out, &h->fin_reserved,
		    NULL);
		goto out_2;
	}
	if (h->flags & F_SET_EMPTY)
		goto out_2;
	/* Encode sequence, if set element. */
	if (h->flags & (F_SET_ELEMENT | F_XCHANGE)) {
		if ((error = net2_cp_encode(&ctx, &cp_uint32, out, &h->seq,
		    NULL)) != 0)
			goto out_2;
	}
	/* Encode payload. */
	if (h->flags & F_STRING) {
		if ((error = net2_cp_encode(&ctx, &cp_paddedstring, out,
		    &h->payload.string, NULL)) != 0)
			goto out_2;
	} else if (h->flags & F_XCHANGE) {
		if ((error = net2_cp_encode(proto_ctx,
		    &cp_short_net2_buffer, out,
		    &h->payload.key_exchange.payload, NULL)) != 0)
			goto out_2;
		if (h->flags & F_XCHANGE_SIGNATURE) {
			if ((error = net2_cp_encode(proto_ctx,
			    &cp_net2_signature, out,
			    &h->payload.key_exchange.signature, NULL)) != 0)
				goto out_2;
		}
	} else if ((h->flags & F_TYPEMASK) == F_TYPE_PVER) {
		if ((error = net2_cp_encode(&ctx, &cp_net2_protocol, out,
		    &h->payload.version, NULL)) != 0)
			goto out_2;
		if ((error = net2_cp_encode(&ctx, &cp_uint16, out,
		    &h->payload.num_types, NULL)) != 0)
			goto out_2;
		if ((error = net2_cp_encode(&ctx, &cp_uint16, out,
		    &h->payload.num_settypes, NULL)) != 0)
			goto out_2;
		if ((error = net2_cp_encode(&ctx, &cp_uint32, out,
		    &h->payload.options, NULL)) != 0)
			goto out_2;
		if ((error = net2_cp_encode(&ctx, &cp_uint32, out,
		    &h->payload.reserved, NULL)) != 0)
			goto out_2;
	} else {
		if ((error = net2_cp_encode(&ctx, &cp_uint32, out,
		    &h->payload.val, NULL)) != 0)
			goto out_2;
	}

	error = 0;

out_2:
	net2_encdec_ctx_deinit(&ctx);
out_1:
	net2_pvlist_deinit(&pv);
out_0:
	return error;
}

/* Decode header. */
static int
cp_header_decode(struct net2_encdec_ctx *proto_ctx, struct header *h,
    struct net2_buffer *in, const void *arg)
{
	struct net2_encdec_ctx	 ctx;
	struct net2_pvlist	 pv;
	int			 error;

	memset(h, 0, sizeof(*h));

	/* Initialize ctx. */
	if ((error = net2_pvlist_init(&pv)) != 0)
		goto out_0;
	if ((error = net2_pvlist_add(&pv, &net2_proto, 0)) != 0)
		goto out_1;
	if ((error = net2_encdec_ctx_init(&ctx, NULL, NULL)) != 0)
		goto out_2;

	/* Decode flags. */
	if ((error = net2_cp_decode(&ctx, &cp_uint32, &h->flags, in,
	    NULL)) != 0)
		goto out_2;
	if (h->flags == F_LAST_HEADER) {
		error = net2_cp_decode(&ctx, &cp_uint32, &h->fin_reserved, in,
		    NULL);
		goto out_2;
	}

	/* Set handling. */
	if (h->flags & F_SET_EMPTY)
		goto out_2;
	/* Decode sequence, if set element. */
	if (h->flags & (F_SET_ELEMENT | F_XCHANGE)) {
		if ((error = net2_cp_decode(&ctx, &cp_uint32, &h->seq, in,
		    NULL)) != 0)
			goto out_2;
	}

	/* Decode payload. */
	if (h->flags & F_STRING) {
		if ((error = net2_cp_decode(&ctx, &cp_paddedstring,
		    &h->payload.string, in, NULL)) != 0)
			goto out_2;
	} else if (h->flags & F_XCHANGE) {
		if ((error = net2_cp_decode(proto_ctx,
		    &cp_short_net2_buffer,
		    &h->payload.key_exchange.payload, in, NULL)) != 0)
			goto out_2;
		if (h->flags & F_XCHANGE_SIGNATURE) {
			if ((error = net2_cp_decode(proto_ctx,
			    &cp_net2_signature,
			    &h->payload.key_exchange.signature,
			    in, NULL)) != 0)
				goto out_2;
		}
	} else if ((h->flags & F_TYPEMASK) == F_TYPE_PVER) {
		if ((error = net2_cp_decode(&ctx, &cp_net2_protocol,
		    &h->payload.version, in, NULL)) != 0)
			goto out_2;
		if ((error = net2_cp_decode(&ctx, &cp_uint16,
		    &h->payload.num_types, in, NULL)) != 0)
			goto out_2;
		if ((error = net2_cp_decode(&ctx, &cp_uint16,
		    &h->payload.num_settypes, in, NULL)) != 0)
			goto out_2;
		if ((error = net2_cp_decode(&ctx, &cp_uint32,
		    &h->payload.options, in, NULL)) != 0)
			goto out_2;
		if ((error = net2_cp_decode(&ctx, &cp_uint32,
		    &h->payload.reserved, in, NULL)) != 0)
			goto out_2;
	} else {
		if ((error = net2_cp_decode(&ctx, &cp_uint32,
		    &h->payload.val, in, NULL)) != 0)
			goto out_2;
	}

	error = 0;

out_2:
	net2_encdec_ctx_deinit(&ctx);
out_1:
	net2_pvlist_deinit(&pv);
out_0:
	return error;
}

/* Initialize header. */
static int
cp_header_init(struct net2_encdec_ctx *ignored_ctx, struct header *h,
    const void *arg)
{
	memset(h, 0, sizeof(*h));
	return 0;
}
/* Destroy header. */
static int
cp_header_destroy(struct net2_encdec_ctx *ignored_ctx, struct header *h,
    const void *arg)
{
	deinit_header(h);
	return 0;
}


ILIAS_NET2_LOCAL const struct header	header_fini = {
	F_LAST_HEADER,
	0,		/* reserved */
	/* Rest is undefined. */
	0,
	{}
};
