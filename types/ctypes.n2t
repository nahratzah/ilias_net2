/*
 * Copyright (c) 2012 Ariane van der Steldt <ariane@stack.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <ilias/net2/ilias_net2_export.h>
%%
#include <ilias/net2/ctypes.h>
#include <stdint.h>
%%

type uint8 (
	ctype uint8_t,
	encode cp_uint8_encode,
	decode cp_uint8_decode
);

type uint16 (
	ctype uint16_t,
	encode cp_uint16_encode,
	decode cp_uint16_decode
);

type uint32 (
	ctype uint32_t,
	encode cp_uint32_encode,
	decode cp_uint32_decode
);

type uint64 (
	ctype uint64_t,
	encode cp_uint64_encode,
	decode cp_uint64_decode
);


type int8 (
	ctype int8_t,
	encode cp_int8_encode,
	decode cp_int8_decode
);

type int16 (
	ctype int16_t,
	encode cp_int16_encode,
	decode cp_int16_decode
);

type int32 (
	ctype int32_t,
	encode cp_int32_encode,
	decode cp_int32_decode
);

type int64 (
	ctype int64_t,
	encode cp_int64_encode,
	decode cp_int64_decode
);


type string (
	ctype char*,
	encode cp_string_encode,
	decode cp_string_decode,
	init cp_string_init,
	destroy cp_string_destroy
);

type paddedstring (
	ctype char*,
	encode cp_paddedstring_encode,
	decode cp_paddedstring_decode,
	init cp_string_init,
	destroy cp_string_destroy
);

type net2_buffer (
	ctype struct net2_buffer*,
	encode cp_net2_buffer32_encode,
	decode cp_net2_buffer32_decode,
	init cp_net2_buffer_init,
	destroy cp_net2_buffer_destroy
);

type short_net2_buffer (
	ctype struct net2_buffer*,
	encode cp_net2_buffer16_encode,
	decode cp_net2_buffer16_decode,
	init cp_net2_buffer_init,
	destroy cp_net2_buffer_destroy
);

type null_stringlist (
	ctype char**,
	encode cp_null_stringlist_encode,
	decode cp_null_stringlist_decode,
	init cp_null_stringlist_init,
	destroy cp_null_stringlist_destroy
);

type net2_protocol (
	ctype net2_protocol_t,
	encode cp_uint32_encode,
	decode cp_uint32_decode
);

%%


#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <ilias/net2/bsd_compat/endian.h>
#include <ilias/net2/buffer.h>
#include <ilias/net2/memory.h>
#include <errno.h>

#include <assert.h>
#include <stdio.h>

/*
 * By padding, we prevent for instance strings upsetting the datastructures
 * following it.
 */
#define PAD		8 /* bytes */

/* Pad size to multiple of PAD. */
static __inline size_t
padded_size(size_t len)
{
	return (len + PAD - 1) & ~((size_t)(PAD - 1));
}

/* Test if the value can be read from the buffer directly. */
static __inline void*
direct(struct net2_buffer *in, size_t len)
{
	struct iovec	vec;

	if ((len & (len - 1)) != 0)
		return NULL;
	if (net2_buffer_peek(in, len, &vec, 1) == 1 &&
	    vec.iov_len >= len &&
	    ((size_t)vec.iov_base & (len - 1)) == 0)
		return vec.iov_base;
	return NULL;
}


ILIAS_NET2_LOCAL int
cp_uint8_encode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    struct net2_buffer *out, const uint8_t *val,
    const void *cp_arg ILIAS_NET2__unused)
{
	if (net2_buffer_add(out, val, sizeof(*val)))
		return ENOMEM;
	return 0;
}
ILIAS_NET2_LOCAL int
cp_uint8_decode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    uint8_t *val, struct net2_buffer *in,
    const void *cp_arg ILIAS_NET2__unused)
{
	if (net2_buffer_remove(in, val, sizeof(*val)) != sizeof(*val))
		return EIO;
	return 0;
}

ILIAS_NET2_LOCAL int
cp_uint16_encode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    struct net2_buffer *out, const uint16_t *val,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint16_t be = htobe16(*val);
	if (net2_buffer_add(out, &be, sizeof(be)))
		return ENOMEM;
	return 0;
}
ILIAS_NET2_LOCAL int
cp_uint16_decode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    uint16_t *val, struct net2_buffer *in,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint16_t	  be;
	uint16_t	 *p;

	if ((p = direct(in, sizeof(*p))) != NULL) {
		*val = betoh16(*p);
		net2_buffer_drain(in, sizeof(*p));
		return 0;
	}

	if (net2_buffer_remove(in, &be, sizeof(be)) != sizeof(be))
		return EIO;
	*val = betoh16(be);
	return 0;
}

ILIAS_NET2_LOCAL int
cp_uint32_encode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    struct net2_buffer *out, const uint32_t *val,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint32_t be = htobe32(*val);
	if (net2_buffer_add(out, &be, sizeof(be)))
		return ENOMEM;
	return 0;
}
ILIAS_NET2_LOCAL int
cp_uint32_decode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    uint32_t *val, struct net2_buffer *in,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint32_t	 be;
	uint32_t	*p;

	if ((p = direct(in, sizeof(*p))) != NULL) {
		*val = betoh32(*p);
		net2_buffer_drain(in, sizeof(*p));
		return 0;
	}

	if (net2_buffer_remove(in, &be, sizeof(be)) != sizeof(be))
		return EIO;
	*val = betoh32(be);
	return 0;
}

ILIAS_NET2_LOCAL int
cp_uint64_encode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    struct net2_buffer *out, const uint64_t *val,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint64_t be = htobe64(*val);
	if (net2_buffer_add(out, &be, sizeof(be)))
		return ENOMEM;
	return 0;
}
ILIAS_NET2_LOCAL int
cp_uint64_decode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    uint64_t *val, struct net2_buffer *in,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint64_t	 be;
	uint64_t	*p;

	if ((p = direct(in, sizeof(*p))) != NULL) {
		*val = betoh64(*p);
		net2_buffer_drain(in, sizeof(*p));
		return 0;
	}

	if (net2_buffer_remove(in, &be, sizeof(be)) != sizeof(be))
		return EIO;
	*val = betoh64(be);
	return 0;
}

ILIAS_NET2_LOCAL int
cp_int8_encode(struct net2_encdec_ctx *c,
    struct net2_buffer *out, const int8_t *val, const void *cp_arg)
{
	uint8_t u;

	if (*val < 0)
		u = (*val + 0x80) | 0x80;
	else
		u = *val;
	return net2_cp_encode(c, &cp_uint8, out, &u, cp_arg);
}
ILIAS_NET2_LOCAL int
cp_int8_decode(struct net2_encdec_ctx *c,
    int8_t *val, struct net2_buffer *in, const void *cp_arg)
{
	uint8_t	 u;
	int	 error;

	if ((error = net2_cp_decode(c, &cp_uint8, &u, in, cp_arg)) != 0)
		return error;
	*val = u & 0x7f;
	if (u & 0x80)
		*val -= 0x80;
	return 0;
}

ILIAS_NET2_LOCAL int
cp_int16_encode(struct net2_encdec_ctx *c,
    struct net2_buffer *out, const int16_t *val, const void *cp_arg)
{
	uint16_t u;

	if (*val < 0)
		u = (*val + 0x8000) | 0x8000;
	else
		u = *val;
	return net2_cp_encode(c, &cp_uint16, out, &u, cp_arg);
}
ILIAS_NET2_LOCAL int
cp_int16_decode(struct net2_encdec_ctx *c,
    int16_t *val, struct net2_buffer *in, const void *cp_arg)
{
	uint16_t u;
	int	 error;

	if ((error = net2_cp_decode(c, &cp_uint16, &u, in, cp_arg)) != 0)
		return error;
	*val = u & 0x7fff;
	if (u & 0x8000)
		*val -= 0x8000;
	return 0;
}

ILIAS_NET2_LOCAL int
cp_int32_encode(struct net2_encdec_ctx *c,
    struct net2_buffer *out, const int32_t *val, const void *cp_arg)
{
	uint32_t u;

	if (*val < 0)
		u = (*val + 0x80000000) | 0x80000000;
	else
		u = *val;
	return net2_cp_encode(c, &cp_uint32, out, &u, cp_arg);
}
ILIAS_NET2_LOCAL int
cp_int32_decode(struct net2_encdec_ctx *c,
    int32_t *val, struct net2_buffer *in, const void *cp_arg)
{
	uint32_t u;
	int	 error;

	if ((error = net2_cp_decode(c, &cp_uint32, &u, in, cp_arg)) != 0)
		return error;
	*val = u & 0x7fffffff;
	if (u & 0x80000000)
		*val -= 0x80000000;
	return 0;
}

ILIAS_NET2_LOCAL int
cp_int64_encode(struct net2_encdec_ctx *c,
    struct net2_buffer *out, const int64_t *val, const void *cp_arg)
{
	uint64_t u;

	if (*val < 0)
		u = (*val + 0x8000000000000000ULL) | 0x8000000000000000ULL;
	else
		u = *val;
	return net2_cp_encode(c, &cp_uint64, out, &u, cp_arg);
}
ILIAS_NET2_LOCAL int
cp_int64_decode(struct net2_encdec_ctx *c,
    int64_t *val, struct net2_buffer *in, const void *cp_arg)
{
	uint64_t u;
	int	 error;

	if ((error = net2_cp_decode(c, &cp_uint64, &u, in, cp_arg)) != 0)
		return error;
	*val = u & 0x7fffffffffffffffULL;
	if (u & 0x8000000000000000ULL)
		*val -= 0x8000000000000000ULL;
	return 0;
}


ILIAS_NET2_LOCAL int
cp_paddedstring_encode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    struct net2_buffer *out, char*const*s,
    const void *cp_arg ILIAS_NET2__unused)
{
	size_t			len;
	static const char	pad[PAD] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	int			error;

	if (*s == NULL)
		return EINVAL;
	len = strlen(*s) + 1;
	if ((error = net2_buffer_add(out, *s, len)) != 0)
		return error;

	if (padded_size(len) != len)
		return net2_buffer_add(out, &pad[0], padded_size(len) - len);
	return 0;
}
ILIAS_NET2_LOCAL int
cp_paddedstring_decode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    char**s, struct net2_buffer *in,
    const void *cp_arg ILIAS_NET2__unused)
{
	struct net2_buffer_ptr	end;
	const char		nullchar = '\0';
	int			err = 0;
	size_t			len;

	if (*s != NULL)
		return EINVAL;

	if (net2_buffer_search(in, &end, &nullchar, sizeof(nullchar), NULL)) {
		err = EIO;
		goto out;
	}

	len = padded_size(end.pos + 1);
	if ((*s = net2_malloc(len)) == NULL) {
		err = ENOMEM;
		goto out;
	}
	if (net2_buffer_remove(in, *s, len) != len)
		err = EIO;
	else
		err = 0;

out:
	if (err != 0 && *s != NULL)
		net2_free(*s);
	return err;
}


ILIAS_NET2_LOCAL int
cp_string_encode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    struct net2_buffer *out, char*const*s,
    const void *cp_arg ILIAS_NET2__unused)
{
	if (*s == NULL)
		return EINVAL;
	return net2_buffer_add(out, *s, strlen(*s) + 1);
}
ILIAS_NET2_LOCAL int
cp_string_decode(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    char**s, struct net2_buffer *in,
    const void *cp_arg ILIAS_NET2__unused)
{
	struct net2_buffer_ptr	end;
	const char		nullchar = '\0';
	int			err = 0;

	if (*s != NULL)
		return EINVAL;

	if (net2_buffer_search(in, &end, &nullchar, sizeof(nullchar), NULL)) {
		err = EIO;
		goto out;
	}

	if ((*s = net2_malloc(end.pos + 1)) == NULL) {
		err = ENOMEM;
		goto out;
	}
	if (net2_buffer_remove(in, *s, end.pos + 1) != end.pos + 1)
		err = EIO;
	else
		err = 0;

out:
	if (err != 0 && *s != NULL)
		net2_free(*s);
	return err;
}
ILIAS_NET2_LOCAL int
cp_string_init(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    char**s, const void *cp_arg ILIAS_NET2__unused)
{
	*s = NULL;
	return 0;
}
ILIAS_NET2_LOCAL int
cp_string_destroy(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    char**s, const void *cp_arg ILIAS_NET2__unused)
{
	if (*s != NULL)
		net2_free(*s);
	*s = NULL;
	return 0;
}


ILIAS_NET2_LOCAL int
cp_net2_buffer32_encode(struct net2_encdec_ctx *c,
    struct net2_buffer *out, struct net2_buffer*const*buf,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint32_t		 sz;
	size_t			 sz_full;
	int			 err;

	/*
	 * Store length of the buffer.
	 */
	sz_full = net2_buffer_length(*buf);
	if (sz_full >= 0xffffffff)
		return ENOMEM;
	sz = sz_full;
	if ((err = net2_cp_encode(c, &cp_uint32, out, &sz, NULL)) != 0)
		return err;

	/*
	 * Append the buffer itself.
	 */
	if (net2_buffer_append(out, *buf))
		return ENOMEM;

	return 0;
}
ILIAS_NET2_LOCAL int
cp_net2_buffer32_decode(struct net2_encdec_ctx *c,
    struct net2_buffer**buf, struct net2_buffer *in,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint32_t		 sz;
	int			 err;

	if (*buf != NULL)
		return EINVAL;

	/* Retrieve buffer length. */
	if ((err = net2_cp_decode(c, &cp_uint32, &sz, in, NULL)) != 0)
		return err;

	/* Drain in into newly allocated buffer. */
	if ((*buf = net2_buffer_new()) == NULL) {
		err = ENOMEM;
		goto fail;
	}
	if (net2_buffer_remove_buffer(in, *buf, sz) != sz) {
		err = EIO;
		goto fail_copy;
	}

	return 0;

fail_copy:
	net2_buffer_free(*buf);
	*buf = NULL;
fail:
	return err;
}

ILIAS_NET2_LOCAL int
cp_net2_buffer16_encode(struct net2_encdec_ctx *c,
    struct net2_buffer *out, struct net2_buffer*const*buf,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint16_t		 sz;
	size_t			 sz_full;
	int			 err;

	/*
	 * Store length of the buffer.
	 */
	sz_full = net2_buffer_length(*buf);
	if (sz_full >= 0xffff)
		return EDOM;
	sz = sz_full;
	if ((err = net2_cp_encode(c, &cp_uint16, out, &sz, NULL)) != 0)
		return err;

	/*
	 * Append the buffer itself.
	 */
	if (net2_buffer_append(out, *buf))
		return ENOMEM;
	return 0;
}
ILIAS_NET2_LOCAL int
cp_net2_buffer16_decode(struct net2_encdec_ctx *c,
    struct net2_buffer**buf, struct net2_buffer *in,
    const void *cp_arg ILIAS_NET2__unused)
{
	uint16_t		 sz;
	int			 err;

	if (*buf != NULL)
		return EINVAL;

	/* Retrieve buffer length. */
	if ((err = net2_cp_decode(c, &cp_uint16, &sz, in, NULL)) != 0)
		goto fail;

	/* Drain in into newly allocated buffer. */
	if ((*buf = net2_buffer_new()) == NULL) {
		err = ENOMEM;
		goto fail;
	}
	if (net2_buffer_remove_buffer(in, *buf, sz) != sz) {
		err = EIO;
		goto fail_copy;
	}

	return 0;

fail_copy:
	net2_buffer_free(*buf);
	*buf = NULL;
fail:
	return err;
}

ILIAS_NET2_LOCAL int
cp_net2_buffer_init(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    struct net2_buffer**buf, const void *cp_arg ILIAS_NET2__unused)
{
	*buf = NULL;
	return 0;
}
ILIAS_NET2_LOCAL int
cp_net2_buffer_destroy(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    struct net2_buffer**buf, const void *cp_arg ILIAS_NET2__unused)
{
	if (*buf != NULL)
		net2_buffer_free(*buf);
	*buf = NULL;
	return 0;
}

ILIAS_NET2_LOCAL int
cp_null_stringlist_encode(struct net2_encdec_ctx *c,
    struct net2_buffer *out, char**const*slistptr, const void *cp_arg)
{
	char			**slist;
	uint16_t		 count;
	struct net2_buffer	*tmp;
	int			 err;

	if ((tmp = net2_buffer_new()) == NULL)
		return ENOMEM;

	/* Calculate count. */
	count = 0;
	for (slist = *slistptr; slist != NULL && *slist != NULL; slist++) {
		if (++count == 0) {	/* Handle overflow. */
			err = EDOM;
			goto fail;
		}
		if ((err = cp_string_encode(c, tmp, slist, cp_arg)) != 0)
			goto fail;
	}

	/* Write count to out. */
	if ((err = cp_uint16_encode(c, out, &count, cp_arg)) != 0)
		goto fail;
	/* Append encoded data. */
	if (count > 0 && net2_buffer_append(out, tmp)) {
		err = ENOMEM;
		goto fail;
	}

	err = 0;
fail:
	net2_buffer_free(tmp);
	return err;
}
ILIAS_NET2_LOCAL int
cp_null_stringlist_decode(struct net2_encdec_ctx *c,
    char***slistptr, struct net2_buffer *in, const void *cp_arg)
{
	char			**slist;
	uint16_t		 count;
	int			 err;

	if ((err = cp_uint16_decode(c, &count, in, cp_arg)) != 0)
		return err;
	*slistptr = slist = net2_calloc((size_t)count + 1, sizeof(*slist));
	if (slist == NULL) {
		err = ENOMEM;
		goto fail;
	}
	while (count > 0) {
		if ((err = cp_string_decode(c, slist, in, cp_arg)) != 0)
			goto fail;
		count--;
		slist++;
	}

	return 0;

fail:
	if (*slistptr != NULL) {
		for (slist = *slistptr; *slist != NULL; slist++)
			net2_free(*slist);
		net2_free(*slistptr);
		*slistptr = NULL;
	}
	return err;
}
ILIAS_NET2_LOCAL int
cp_null_stringlist_init(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    char***slistptr, const void *cp_arg ILIAS_NET2__unused)
{
	*slistptr = NULL;
	return 0;
}
ILIAS_NET2_LOCAL int
cp_null_stringlist_destroy(struct net2_encdec_ctx *c ILIAS_NET2__unused,
    char***slistptr, const void *cp_arg ILIAS_NET2__unused)
{
	char			**slist;

	if (slistptr != NULL) {
		for (slist = *slistptr; *slist != NULL; slist++)
			net2_free(*slist);
		net2_free(*slistptr);
		*slistptr = NULL;
	}
	return 0;
}
