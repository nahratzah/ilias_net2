/*
 * Copyright (c) 2012 Ariane van der Steldt <ariane@stack.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <stdint.h>
#include <ilias/net2/types.h>
#include <ilias/net2/buffer.h>
#include <ilias/net2/protocol.h>

/*
 * Here are all the protocol messages defined that the objmanager uses to
 * coordinate between the local and remote endpoints.
 */


/*
 * Protocol header.
 * flags: declare what was sent
 */
struct net2_objman_proto_header {
	uint32_t	 flags;		/* Options. */
#define OBJMAN_PH_IS_MASK	0xf0000000	/* Request type mask. */
#define OBJMAN_PH_IS_MASK_SHIFT	28		/* Shift for switch. */
#define OBJMAN_PH_IS_OBJMAN	0x00000000	/* MSB: objman request */
#define OBJMAN_PH_IS_REQUEST	0x10000000	/* New request. */
#define OBJMAN_PH_IS_RESPONSE	0x20000000	/* Response of request. */
#define OBJMAN_PH_IS_SUPERSEDE	0x30000000	/* Superseded request. */
#define OBJMANRESP_PH_FINSTATE	0x0000000f	/* Finish how state. */
};

/*
 * Objman invocation request.
 *
 * Describes which method to invoke.
 */
struct net2_objman_invocation {
	uint32_t		 seq;		/* Sequence and request ID. */
	uint32_t		 barrier;	/* Invocation barrier seq. */
	uint32_t		 group;		/* Main group. */
	uint32_t		 proto;		/* Method protocol. */
	uint32_t		 method;	/* Method number. */
};

/* Invocation request. */
struct net2_objman_request {
	struct net2_objman_invocation
				 invocation;	/* Invocation header. */
	const struct command_method
				*method;	/* Invoked method. */
	void			*in_param;	/* Input parameters. */
	struct net2_buffer	*in_param_buf;	/* Pre-encoded in_param. */
};


/*
 * Objman supersede request.
 *
 * Describes which request to supersede.
 */
struct net2_objman_supersede {
	uint32_t		 seq;		/* Sequence and request ID. */
	uint32_t		 group;		/* Main group. */
};


/*
 * Objman response.
 *
 * Contains the response of an invoked message.
 */
struct net2_objman_response {
	uint32_t		 seq;		/* Sequence and request ID. */
	uint32_t		 group;		/* Main group. */

	int			 finish_how;	/* How the call finished. */
	uint32_t		 error;		/* Error code. */

	const struct command_param
				*result_type;	/* Type of result. */
	void			*result;	/* Decoded result. */
	struct net2_objman_tx_ticket
				*tx;		/* Ticket. */
};


/* A single data packet from/for objman. */
struct net2_objman_packet {
	struct net2_objman_proto_header	mh;

	union {
		struct net2_objman_request	request;
		struct net2_objman_supersede	supersede;
		struct net2_objman_response	response;
	};
};

ILIAS_NET2_LOCAL
int	n2omp_decode(struct net2_encdec_ctx*,
	    struct net2_objman_packet*, struct net2_buffer*);

ILIAS_NET2_LOCAL
int	n2omp_encode_request(struct net2_encdec_ctx*, struct net2_buffer*,
	    uint32_t /*seq*/, uint32_t /*barrier*/, uint32_t /*group*/,
	    const struct command_method*, struct net2_buffer*);
ILIAS_NET2_LOCAL
int	n2omp_encode_response_ok(struct net2_encdec_ctx*, struct net2_buffer*,
	    uint32_t /*seq*/, uint32_t /*group*/,
	    const struct command_method*, const void*);
ILIAS_NET2_LOCAL
int	n2omp_encode_response_error(struct net2_encdec_ctx*,
	    struct net2_buffer*, uint32_t /*seq*/, uint32_t /*group*/,
	    uint32_t /*error*/);
ILIAS_NET2_LOCAL
int	n2omp_encode_response_generic(struct net2_encdec_ctx*,
	    struct net2_buffer*, uint32_t /*seq*/, uint32_t /*group*/,
	    int /*finish_how*/);
ILIAS_NET2_LOCAL
int	n2omp_encode_supersede(struct net2_encdec_ctx*, struct net2_buffer*,
	    uint32_t /*seq*/, uint32_t /*group*/);

%%
#include "obj_manager_proto.h"
#include <ilias/net2/ctypes.h>
#include <ilias/net2/protocol.h>
#include <ilias/net2/obj_manager.h>
#include <stdlib.h>
#include <errno.h>
%%

struct net2_objman_proto_header (ctype struct net2_objman_proto_header, protocol net2_proto) {
	uint32		 flags;
};

struct net2_objman_invocation (ctype struct net2_objman_invocation, protocol net2_proto) {
	uint32		 seq;
	uint32		 barrier;
	uint32		 group;
	uint32		 proto;
	uint32		 method;
};

struct net2_objman_supersede (ctype struct net2_objman_supersede, protocol net2_proto) {
	uint32		 seq;
	uint32		 group;
};

type net2_objman_response (ctype struct net2_objman_response,
    argument	struct net2_objman_proto_header,
    encode	n2om_resp_encode,
    decode	n2om_resp_decode,
    init	n2om_resp_init,
    destroy	n2om_resp_destroy
);

type net2_objman_request (ctype struct net2_objman_request,
    argument	struct net2_objman_proto_header,
    encode	n2om_req_encode,
    decode	n2om_req_decode,
    init	n2om_req_init,
    destroy	n2om_req_destroy
);

%%

/* Drain objman packet from in. */
ILIAS_NET2_LOCAL int
n2omp_decode(struct net2_encdec_ctx *c, struct net2_objman_packet *p,
    struct net2_buffer *in)
{
	int				 error;

	/* Decode message header. */
	if ((error = net2_cp_decode(c, &cp_net2_objman_proto_header, &p->mh, in,
	    NULL)) != 0)
		return error;

	switch ((p->mh.flags & OBJMAN_PH_IS_MASK) >> OBJMAN_PH_IS_MASK_SHIFT) {
	case OBJMAN_PH_IS_REQUEST >> OBJMAN_PH_IS_MASK_SHIFT:
		if ((error = net2_cp_decode(c, &cp_net2_objman_request,
		    &p->request, in, NULL)) != 0)
			return error;
		break;

	case OBJMAN_PH_IS_SUPERSEDE >> OBJMAN_PH_IS_MASK_SHIFT:
		if ((error = net2_cp_decode(c, &cp_net2_objman_supersede,
		    &p->supersede, in, NULL)) != 0)
			return error;
		break;

	case OBJMAN_PH_IS_RESPONSE >> OBJMAN_PH_IS_MASK_SHIFT:
		if ((error = net2_cp_decode(c, &cp_net2_objman_response,
		    &p->response, in, &p->mh)) != 0)
			return error;
		break;

	case OBJMAN_PH_IS_OBJMAN >> OBJMAN_PH_IS_MASK_SHIFT:
		return -1;	/* TODO: implement */

	default:
		/* Message not recognized. */
		return EINVAL;
	}

	return 0;
}

/* Encode a request. */
ILIAS_NET2_LOCAL int
n2omp_encode_request(struct net2_encdec_ctx *c, struct net2_buffer *out,
    uint32_t seq, uint32_t barrier, uint32_t group,
    const struct command_method *cm, struct net2_buffer *in_param_buf)
{
	struct net2_objman_packet	 p;
	struct net2_objman_request	*r;
	int				 error;
	const struct net2_protocol	*protocol;

	protocol = cm->cm_protocol;
	p.mh.flags = OBJMAN_PH_IS_REQUEST;
	r = &p.request;

	/* Fill in invocation values. */
	r->invocation.seq = seq;
	r->invocation.barrier = barrier;
	r->invocation.group = group;

	if (net2_pvlist_get(&c->ed_proto, protocol, &r->invocation.proto))
		return ESRCH;
	if (net2_protocol_method_id(protocol, cm, &r->invocation.method))
		return ESRCH;

	/* Setup request data. */
	r->method = cm;
	r->in_param = NULL;
	r->in_param_buf = in_param_buf;

	/* Encode protocol header. */
	if ((error = net2_cp_encode(c, &cp_net2_objman_proto_header, out,
	    &p.mh, NULL)) != 0)
		return error;
	if ((error = net2_cp_encode(c, &cp_net2_objman_request, out,
	    r, &p.mh)) != 0)
		return error;

	return 0;
}

ILIAS_NET2_LOCAL int
n2omp_encode_response_ok(struct net2_encdec_ctx *c, struct net2_buffer *out,
    uint32_t seq, uint32_t group,
    const struct command_method *cm, const void *out_param)
{
	struct net2_objman_packet	 p;
	struct net2_objman_response	*r;
	int				 error;

	if (cm == NULL)
		return EINVAL;

	p.mh.flags = OBJMAN_PH_IS_RESPONSE;
	r = &p.response;

	/* Fill in response ID. */
	r->seq = seq;
	r->group = group;
	r->finish_how = NET2_IVCTX_FIN_OK;
	r->error = 0;
	r->result_type = cm->cm_out;
	r->result = (void*)out_param;
	r->tx = NULL;	/* Unused during encoding. */

	/* Apply finstate to header flags. */
	if (r->finish_how & ~OBJMANRESP_PH_FINSTATE)
		return ERANGE;
	p.mh.flags |= (r->finish_how & OBJMANRESP_PH_FINSTATE);

	/* Encode protocol header. */
	if ((error = net2_cp_encode(c, &cp_net2_objman_proto_header, out,
	    &p.mh, NULL)) != 0)
		return error;
	if ((error = net2_cp_encode(c, &cp_net2_objman_response, out,
	    r, &p.mh)) != 0)
		return error;

	return 0;
}
ILIAS_NET2_LOCAL int
n2omp_encode_response_error(struct net2_encdec_ctx *c, struct net2_buffer *out,
    uint32_t seq, uint32_t group, uint32_t errorcode)
{
	struct net2_objman_packet	 p;
	struct net2_objman_response	*r;
	int				 error;

	p.mh.flags = OBJMAN_PH_IS_RESPONSE;
	r = &p.response;

	/* Fill in response ID. */
	r->seq = seq;
	r->group = group;
	r->finish_how = NET2_IVCTX_FIN_ERROR;
	r->error = errorcode;
	r->result_type = NULL;
	r->result = NULL;
	r->tx = NULL;	/* Unused during encoding. */

	/* Apply finstate to header flags. */
	if (r->finish_how & ~OBJMANRESP_PH_FINSTATE)
		return ERANGE;
	p.mh.flags |= (r->finish_how & OBJMANRESP_PH_FINSTATE);

	/* Encode protocol header. */
	if ((error = net2_cp_encode(c, &cp_net2_objman_proto_header, out,
	    &p.mh, NULL)) != 0)
		return error;
	if ((error = net2_cp_encode(c, &cp_net2_objman_response, out,
	    r, &p.mh)) != 0)
		return error;

	return 0;
}
ILIAS_NET2_LOCAL int
n2omp_encode_response_generic(struct net2_encdec_ctx *c,
    struct net2_buffer *out, uint32_t seq, uint32_t group, int finish_how)
{
	struct net2_objman_packet	 p;
	struct net2_objman_response	*r;
	int				 error;

	if (finish_how == NET2_IVCTX_FIN_OK ||
	    finish_how == NET2_IVCTX_FIN_ERROR)
		return EINVAL;

	p.mh.flags = OBJMAN_PH_IS_RESPONSE;
	r = &p.response;

	/* Fill in response ID. */
	r->seq = seq;
	r->group = group;
	r->finish_how = finish_how;
	r->error = 0;
	r->result_type = NULL;
	r->result = NULL;
	r->tx = NULL;	/* Unused during encoding. */

	/* Apply finstate to header flags. */
	if (r->finish_how & ~OBJMANRESP_PH_FINSTATE)
		return ERANGE;
	p.mh.flags |= (r->finish_how & OBJMANRESP_PH_FINSTATE);

	/* Encode protocol header. */
	if ((error = net2_cp_encode(c, &cp_net2_objman_proto_header, out,
	    &p.mh, NULL)) != 0)
		return error;
	if ((error = net2_cp_encode(c, &cp_net2_objman_response, out,
	    r, &p.mh)) != 0)
		return error;

	return 0;
}

/* Encode request supersede. */
ILIAS_NET2_LOCAL int
n2omp_encode_supersede(struct net2_encdec_ctx *c, struct net2_buffer *out,
    uint32_t seq, uint32_t group)
{
	struct net2_objman_packet	 p;
	struct net2_objman_supersede	*s;
	int				 error;

	p.mh.flags = OBJMAN_PH_IS_SUPERSEDE;
	s = &p.supersede;

	/* Fill in supersede values. */
	s->seq = seq;
	s->group = group;

	/* Encode protocol header. */
	if ((error = net2_cp_encode(c, &cp_net2_objman_proto_header, out,
	    &p.mh, NULL)) != 0)
		return error;
	if ((error = net2_cp_encode(c, &cp_net2_objman_supersede, out,
	    s, &p.mh)) != 0)
		return error;

	return 0;
}


static int
n2om_resp_init(struct net2_encdec_ctx *c, struct net2_objman_response *r,
    const struct net2_objman_proto_header *h)
{
	r->result_type = NULL;
	r->result = NULL;
	return 0;
}

static int
n2om_resp_destroy(struct net2_encdec_ctx *c, struct net2_objman_response *r,
    const struct net2_objman_proto_header *h)
{
	int				 error;

	error = 0;
	if (r->result) {
		if (r->result_type == NULL)
			return EINVAL;
		error = net2_cp_destroy_alloc(c, r->result_type,
		    &r->result, NULL);
	}
	return error;
}

static int
n2om_resp_encode(struct net2_encdec_ctx *c, struct net2_buffer *out,
    const struct net2_objman_response *r,
    const struct net2_objman_proto_header *h)
{
	int	err;
	int	fin_how;

	fin_how = (h->flags & OBJMANRESP_PH_FINSTATE);

	/* Handle sequence and group. */
	if ((err = net2_cp_encode(c, &cp_uint32, out, &r->seq, NULL)) != 0)
		return err;
	if ((err = net2_cp_encode(c, &cp_uint32, out, &r->group, NULL)) != 0)
		return err;

	switch (fin_how) {
	case NET2_IVCTX_FIN_ERROR:
		/* Handle error code. */
		if ((err = net2_cp_encode(c, &cp_uint32, out, &r->error, NULL)) != 0)
			return err;
		break;
	case NET2_IVCTX_FIN_OK:
		if (r->result_type != NULL) {
			if (r->result == NULL)
				return EINVAL;
			if ((err = net2_cp_encode(c, r->result_type, out,
			    r->result, NULL)) != 0)
				return err;
		}
		break;
	}

	return 0;
}

static int
n2om_resp_decode(struct net2_encdec_ctx *c, struct net2_objman_response *r,
    struct net2_buffer *in,
    const struct net2_objman_proto_header *h)
{
	int				 err;
	int				 fin_how;
	struct net2_objman_tx_ticket	*tx;

	fin_how = r->finish_how = (h->flags & OBJMANRESP_PH_FINSTATE);

	/* Handle sequence and group. */
	if ((err = net2_cp_decode(c, &cp_uint32, &r->seq, in, NULL)) != 0)
		return err;
	if ((err = net2_cp_decode(c, &cp_uint32, &r->group, in, NULL)) != 0)
		return err;

	/* Require objman to look up ticket. */
	if (c->ed_objman == NULL)
		return EINVAL;

	/* Lookup ticket. */
	tx = r->tx = net2_objmanager_find_tx_ticket(c->ed_objman,
	    r->seq, r->group);
	if (tx == NULL)
		return EFAULT;

	switch (fin_how) {
	case NET2_IVCTX_FIN_ERROR:
		/* Handle error code. */
		if ((err = net2_cp_decode(c, &cp_uint32, &r->error, in, NULL)) != 0)
			return err;
		break;
	case NET2_IVCTX_FIN_OK:
		/* Handle payload for succesful invocation. */
		r->result_type = net2_objman_ttx_type(tx);
		if (r->result_type != NULL) {
			if ((err = net2_cp_init_alloc(c, r->result_type,
			    &r->result, NULL)) != 0)
				return err;
			if ((err = net2_cp_decode(c, r->result_type, r->result,
			    in, NULL)) != 0)
				return err;
		}
		break;
	}

	return 0;
}


static int
n2om_req_init(struct net2_encdec_ctx *c, struct net2_objman_request *r,
    const struct net2_objman_proto_header *h)
{
	r->method = NULL;
	r->in_param = NULL;
	r->in_param_buf = NULL;
	return 0;
}

static int
n2om_req_destroy(struct net2_encdec_ctx *c, struct net2_objman_request *r,
    const struct net2_objman_proto_header *h)
{
	int			 error;

	error = 0;
	if (r->in_param != NULL && r->method != NULL &&
	    r->method->cm_in != NULL) {
		error = net2_cp_destroy_alloc(c, r->method->cm_in, r->in_param,
		    NULL);
	}
	if (r->in_param_buf != NULL)
		net2_buffer_free(r->in_param_buf);
	return error;
}

static int
n2om_req_encode(struct net2_encdec_ctx *c, struct net2_buffer *out,
    const struct net2_objman_request *r,
    const struct net2_objman_proto_header *h)
{
	int				 error;

	/* Require method to be declared. */
	if (r->method == NULL)
		return EINVAL;

	/* Encode invocation. */
	if ((error = net2_cp_encode(c, &cp_net2_objman_invocation, out,
	    &r->invocation, NULL)) != 0)
		return error;

	/* Encode argument. */
	if (r->method->cm_in != NULL) {
		if (r->in_param_buf != NULL) {
			if (net2_buffer_append(out, r->in_param_buf))
				return ENOMEM;
		} else {
			if (r->in_param == NULL)
				return EINVAL;

			if ((error = net2_cp_encode(c, r->method->cm_in, out,
			    r->in_param, NULL)) != 0)
				return error;
		}
	}

	return 0;
}

static int
n2om_req_decode(struct net2_encdec_ctx *c, struct net2_objman_request *r,
    struct net2_buffer *in, const struct net2_objman_proto_header *h)
{
	int				 error;
	const struct net2_protocol	*protocol;
	const struct command_param	*args;

	if (r->in_param != NULL)
		return EINVAL;

	if ((error = net2_cp_decode(c, &cp_net2_objman_invocation,
	    &r->invocation, in, NULL)) != 0)
		return error;

	/* Protocol lookup. */
	if ((protocol = net2_pvlist_get_by_id(&c->ed_proto,
	    r->invocation.proto)) == NULL)
		return ESRCH;

	/* Method lookup. */
	if ((r->method = net2_protocol_method(protocol,
	    r->invocation.method)) == NULL)
		return ESRCH;
	args = r->method->cm_in;

	/* Decode parameters. */
	if (args == NULL)
		r->in_param = NULL;
	else {
		if ((error = net2_cp_init_alloc(c, args, &r->in_param,
		    NULL)) != 0)
			return error;
		if ((error = net2_cp_decode(c, args, r->in_param, in,
		    NULL)) != 0)
			return error;
	}

	return 0;
}
