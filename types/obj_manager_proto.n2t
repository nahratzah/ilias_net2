#include <stdint.h>
#include <ilias/net2/types.h>
#include <ilias/net2/buffer.h>

/*
 * Here are all the protocol messages defined that the objmanager uses to
 * coordinate between the local and remote endpoints.
 */


/*
 * Protocol header.
 * flags: declare what was sent
 */
struct net2_objman_proto_header {
	uint32_t	 flags;		/* Options. */
#define OBJMAN_PH_IS_MASK	0xf0000000	/* Request type mask. */
#define OBJMAN_PH_IS_MASK_SHIFT	28		/* Shift for switch. */
#define OBJMAN_PH_IS_OBJMAN	0x00000000	/* MSB: objman request */
#define OBJMAN_PH_IS_REQUEST	0x10000000	/* New request. */
#define OBJMAN_PH_IS_RESPONSE	0x20000000	/* Response of request. */
#define OBJMAN_PH_IS_SUPERSEDE	0x30000000	/* Superseded request. */
#define OBJMANRESP_PH_FINSTATE	0x0000000f	/* Finish how state. */
};

/*
 * Objman invocation request.
 *
 * Describes which method to invoke.
 */
struct net2_objman_invocation {
	uint32_t		 seq;		/* Sequence and request ID. */
	uint32_t		 barrier;	/* Invocation barrier seq. */
	uint32_t		 group;		/* Main group. */
	uint32_t		 proto;		/* Method protocol. */
	uint32_t		 method;	/* Method number. */
};

/* Invocation request. */
struct net2_objman_request {
	struct net2_objman_invocation
				 invocation;	/* Invocation header. */
	const struct command_method
				*method;	/* Invoked method. */
	void			*in_param;	/* Input parameters. */
};


/*
 * Objman supersede request.
 *
 * Describes which request to supersede.
 */
struct net2_objman_supersede {
	uint32_t		 seq;		/* Sequence and request ID. */
	uint32_t		 group;		/* Main group. */
};


/*
 * Objman response.
 *
 * Contains the response of an invoked message.
 */
struct net2_objman_response {
	uint32_t		 seq;		/* Sequence and request ID. */
	uint32_t		 group;		/* Main group. */

	int			 finish_how;	/* How the call finished. */
	uint32_t		 error;		/* Error code. */

	const struct command_param
				*result_type;	/* Type of result. */
	void			*result;	/* Decoded result. */
	struct net2_objman_tx_ticket
				*tx;		/* Ticket. */
};


/* A single data packet from/for objman. */
struct net2_objman_packet {
	struct net2_objman_proto_header	mh;

	union {
		struct net2_objman_request	request;
		struct net2_objman_supersede	supersede;
		struct net2_objman_response	response;
	};
};

ILIAS_NET2_LOCAL
int	n2omp_decode(struct net2_encdec_ctx*,
	    struct net2_objman_packet*, struct net2_buffer*);

%%
#include "obj_manager_proto.h"
#include <ilias/net2/ctypes.h>
#include <ilias/net2/protocol.h>
#include <ilias/net2/obj_manager.h>
#include <stdlib.h>
#include <errno.h>
%%

struct net2_objman_proto_header (ctype struct net2_objman_proto_header, protocol net2_proto) {
	uint32		 flags;
};

struct net2_objman_invocation (ctype struct net2_objman_invocation, protocol net2_proto) {
	uint32		 seq;
	uint32		 barrier;
	uint32		 group;
	uint32		 proto;
	uint32		 method;
};

struct net2_objman_supersede (ctype struct net2_objman_supersede, protocol net2_proto) {
	uint32		 seq;
	uint32		 group;
};

type net2_objman_response (ctype struct net2_objman_response,
    argument	struct net2_objman_proto_header,
    encode	n2om_resp_encode,
    decode	n2om_resp_decode,
    init	n2om_resp_init,
    destroy	n2om_resp_destroy
);

type net2_objman_request (ctype struct net2_objman_request,
    argument	struct net2_objman_proto_header,
    encode	n2om_req_encode,
    decode	n2om_req_decode,
    init	n2om_req_init,
    destroy	n2om_req_destroy
);

%%

/* Drain objman packet from in. */
ILIAS_NET2_LOCAL int
n2omp_decode(struct net2_encdec_ctx *c, struct net2_objman_packet *p,
    struct net2_buffer *in)
{
	/* Decode message header. */
	if (net2_cp_decode(c, &cp_net2_objman_proto_header, &p->mh, in, NULL))
		return -1;

	switch ((p->mh.flags & OBJMAN_PH_IS_MASK) >> OBJMAN_PH_IS_MASK_SHIFT) {
	case OBJMAN_PH_IS_REQUEST >> OBJMAN_PH_IS_MASK_SHIFT:
		if (net2_cp_decode(c, &cp_net2_objman_request, &p->request,
		    in, NULL))
			return -1;
		break;

	case OBJMAN_PH_IS_SUPERSEDE >> OBJMAN_PH_IS_MASK_SHIFT:
		if (net2_cp_decode(c, &cp_net2_objman_supersede, &p->supersede,
		    in, NULL))
			return -1;
		break;

	case OBJMAN_PH_IS_RESPONSE >> OBJMAN_PH_IS_MASK_SHIFT:
		if (net2_cp_decode(c, &cp_net2_objman_response,
		    &p->response, in, &p->mh))
			return -1;
		break;

	case OBJMAN_PH_IS_OBJMAN >> OBJMAN_PH_IS_MASK_SHIFT:
		return -1;	/* TODO: implement */

	default:
		/* Message not recognized. */
		return -1;
	}

	return 0;
}


static int
n2om_resp_init(struct net2_encdec_ctx *c, struct net2_objman_response *r,
    const struct net2_objman_proto_header *h)
{
	r->result_type = NULL;
	r->result = NULL;
	return 0;
}

static int
n2om_resp_destroy(struct net2_encdec_ctx *c, struct net2_objman_response *r,
    const struct net2_objman_proto_header *h)
{
	if (r->result) {
		if (r->result_type == NULL)
			return -1;
		if (net2_cp_destroy_alloc(c, r->result_type, &r->result, NULL))
			return -1;
	}
	return 0;
}

static int
n2om_resp_encode(struct net2_encdec_ctx *c, struct net2_buffer *out,
    const struct net2_objman_response *r,
    const struct net2_objman_proto_header *h)
{
	int	err;
	int	fin_how;

	fin_how = (h->flags & OBJMANRESP_PH_FINSTATE);

	/* Handle sequence and group. */
	if ((err = net2_cp_encode(c, &cp_uint32, out, &r->seq, NULL)) != 0)
		return err;
	if ((err = net2_cp_encode(c, &cp_uint32, out, &r->group, NULL)) != 0)
		return err;

	switch (fin_how) {
	case NET2_IVCTX_FIN_ERROR:
		/* Handle error code. */
		if ((err = net2_cp_encode(c, &cp_uint32, out, &r->error, NULL)) != 0)
			return err;
		break;
	case NET2_IVCTX_FIN_OK:
		if (r->result_type != NULL &&
		    (err = net2_cp_encode(c, r->result_type, out, r->result, NULL)) != 0)
			return err;
		break;
	}

	return 0;
}

static int
n2om_resp_decode(struct net2_encdec_ctx *c, struct net2_objman_response *r,
    struct net2_buffer *in,
    const struct net2_objman_proto_header *h)
{
	int				 err;
	int				 fin_how;
	struct net2_objman_tx_ticket	*tx;

	fin_how = r->finish_how = (h->flags & OBJMANRESP_PH_FINSTATE);

	/* Handle sequence and group. */
	if ((err = net2_cp_decode(c, &cp_uint32, &r->seq, in, NULL)) != 0)
		return err;
	if ((err = net2_cp_decode(c, &cp_uint32, &r->group, in, NULL)) != 0)
		return err;

	/* Require objman to look up ticket. */
	if (c->ed_objman == NULL)
		return EINVAL;

	/* Lookup ticket. */
	tx = r->tx = net2_objmanager_find_tx_ticket(c->ed_objman,
	    r->seq, r->group);
	if (tx == NULL)
		return EFAULT;

	switch (fin_how) {
	case NET2_IVCTX_FIN_ERROR:
		/* Handle error code. */
		if ((err = net2_cp_decode(c, &cp_uint32, &r->error, in, NULL)) != 0)
			return err;
		break;
	case NET2_IVCTX_FIN_OK:
		/* Handle payload for succesful invocation. */
		r->result_type = net2_objman_ttx_type(tx);
		if (r->result_type != NULL) {
			if ((err = net2_cp_init_alloc(c, r->result_type,
			    &r->result, NULL)) != 0)
				return err;
			if ((err = net2_cp_decode(c, r->result_type, r->result,
			    in, NULL)) != 0) {
				net2_cp_destroy_alloc(c, r->result_type,
				    &r->result, NULL);
				return err;
			}
		}
		break;
	}

	return 0;
}


static int
n2om_req_init(struct net2_encdec_ctx *c, struct net2_objman_request *r,
    const struct net2_objman_proto_header *h)
{
	r->method = NULL;
	r->in_param = NULL;
	return 0;
}

static int
n2om_req_destroy(struct net2_encdec_ctx *c, struct net2_objman_request *r,
    const struct net2_objman_proto_header *h)
{
	if (r->in_param != NULL && r->method != NULL &&
	    r->method->cm_in != NULL) {
		return net2_cp_destroy_alloc(c, r->method->cm_in, r->in_param,
		    NULL);
	}
	return 0;
}

static int
n2om_req_encode(struct net2_encdec_ctx *c, struct net2_buffer *out,
    const struct net2_objman_request *r,
    const struct net2_objman_proto_header *h)
{
	int				 error;

	/* Require method to be declared. */
	if (r->method == NULL)
		return EINVAL;

	/* Encode invocation. */
	if ((error = net2_cp_encode(c, &cp_net2_objman_invocation, out,
	    &r->invocation, NULL)) != 0)
		return error;

	/* Encode argument. */
	if (r->method->cm_in != NULL) {
		if (r->in_param == NULL)
			return EINVAL;

		if ((error = net2_cp_encode(c, r->method->cm_in, out,
		    r->in_param, NULL)) != 0)
			return error;
	}

	return 0;
}

static int
n2om_req_decode(struct net2_encdec_ctx *c, struct net2_objman_request *r,
    struct net2_buffer *in, const struct net2_objman_proto_header *h)
{
	int				 error;
	const struct net2_protocol	*protocol;
	const struct command_param	*args;

	if (r->in_param != NULL)
		return EINVAL;

	if ((error = net2_cp_decode(c, &cp_net2_objman_invocation,
	    &r->invocation, in, NULL)) != 0)
		return error;

	/* Protocol lookup. */
	if ((protocol = net2_pvlist_get_by_id(&c->ed_proto,
	    r->invocation.proto)) == NULL)
		return -1;

	/* Method lookup. */
	if ((r->method = net2_protocol_method(protocol,
	    r->invocation.method)) == NULL)
		return -1;
	args = r->method->cm_in;

	/* Decode parameters. */
	if (args == NULL)
		r->in_param = NULL;
	else {
		if ((error = net2_cp_init_alloc(c, args, &r->in_param,
		    NULL)) != 0)
			return error;
		if ((error = net2_cp_decode(c, args, r->in_param, in,
		    NULL)) != 0) {
			net2_cp_destroy_alloc(c, args, &r->in_param, NULL);
			return error;
		}
	}

	return 0;
}
