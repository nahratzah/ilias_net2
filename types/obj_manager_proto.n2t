#include <stdint.h>
#include <ilias/net2/types.h>
#include <ilias/net2/buffer.h>

/*
 * Here are all the protocol messages defined that the objmanager uses to
 * coordinate between the local and remote endpoints.
 */


/*
 * Protocol header.
 * flags: declare what was sent
 */
struct net2_objman_proto_header {
	uint32_t	 flags;		/* Options. */
#define OBJMAN_PH_IS_MASK	0xf0000000	/* Request type mask. */
#define OBJMAN_PH_IS_MASK_SHIFT	28		/* Shift for switch. */
#define OBJMAN_PH_IS_OBJMAN	0x00000000	/* MSB: objman request */
#define OBJMAN_PH_IS_REQUEST	0x10000000	/* New request. */
#define OBJMAN_PH_IS_RESPONSE	0x20000000	/* Response of request. */
#define OBJMAN_PH_IS_SUPERSEDE	0x30000000	/* Superseded request. */
#define OBJMANRESP_PH_FINSTATE	0x0000000f	/* Finish how state. */
};

/*
 * Objman invocation request.
 *
 * Describes which method to invoke.
 */
struct net2_objman_invocation {
	uint32_t		 seq;		/* Sequence and request ID. */
	uint32_t		 barrier;	/* Invocation barrier seq. */
	uint32_t		 group;		/* Main group. */
	uint32_t		 proto;		/* Method protocol. */
	uint32_t		 method;	/* Method number. */
};

/* Invocation request. */
struct net2_objman_request {
	struct net2_objman_invocation
				 invocation;	/* Invocation header. */
	const struct command_method
				*method;	/* Invoked method. */
	void			*in_param;	/* Input parameters. */
};


/*
 * Objman supersede request.
 *
 * Describes which request to supersede.
 */
struct net2_objman_supersede {
	uint32_t		 seq;		/* Sequence and request ID. */
	uint32_t		 group;		/* Main group. */
};


/*
 * Objman response.
 *
 * Contains the response of an invoked message.
 */
struct net2_objman_response {
	uint32_t		 seq;		/* Sequence and request ID. */
	uint32_t		 group;		/* Main group. */

	int			 finish_how;	/* How the call finished. */
	uint32_t		 error;		/* Error code. */

	const struct command_param
				*result_type;	/* Type of result. */
	void			*result;	/* Decoded result. */
};


/* A single data packet from/for objman. */
struct net2_objman_packet {
	struct net2_objman_proto_header	mh;

	union {
		struct net2_objman_request	request;
		struct net2_objman_supersede	supersede;
		struct net2_objman_response	response;
	};
};

ILIAS_NET2_LOCAL
int	n2omp_decode_header(struct net2_encdec_ctx*,
	    struct net2_objman_packet*, struct net2_buffer*);

%%
#include "obj_manager_proto.h"
#include <ilias/net2/ctypes.h>
#include <ilias/net2/protocol.h>
#include <stdlib.h>
%%

struct net2_objman_proto_header (ctype struct net2_objman_proto_header, protocol net2_proto) {
	uint32		 flags;
};

struct net2_objman_invocation (ctype struct net2_objman_invocation, protocol net2_proto) {
	uint32		 seq;
	uint32		 barrier;
	uint32		 group;
	uint32		 proto;
	uint32		 method;
};

struct net2_objman_supersede (ctype struct net2_objman_supersede, protocol net2_proto) {
	uint32		 seq;
	uint32		 group;
};

type net2_objman_response (ctype struct net2_objman_response,
    argument	struct net2_objman_proto_header,
    encode	n2om_resp_encode,
    decode	n2om_resp_decode,
    init	n2om_resp_init,
    destroy	n2om_resp_destroy
);

%%

/* Drain objman packet from in. */
ILIAS_NET2_LOCAL int
n2omp_decode_header(struct net2_encdec_ctx *c, struct net2_objman_packet *p,
    struct net2_buffer *in)
{
	const struct net2_protocol	*protocol;
	const struct command_param	*args;

	/* Decode message header. */
	if (net2_cp_decode(c, &cp_net2_objman_proto_header, &p->mh, in, NULL))
		return -1;

	switch ((p->mh.flags & OBJMAN_PH_IS_MASK) >> OBJMAN_PH_IS_MASK_SHIFT) {
	case OBJMAN_PH_IS_REQUEST >> OBJMAN_PH_IS_MASK_SHIFT:
		/* Decode invocation header. */
		if (net2_cp_decode(c, &cp_net2_objman_invocation,
		    &p->request.invocation, in, NULL))
			return -1;

		/* Protocol lookup. */
		if ((protocol = net2_pvlist_get_by_id(&c->ed_proto,
		    p->request.invocation.proto)) == NULL)
			return -1;

		/* Method lookup. */
		if ((p->request.method = net2_protocol_method(protocol,
		    p->request.invocation.method)) == NULL)
			return -1;
		args = p->request.method->cm_in;

		/* Decode parameters. */
		if (args == NULL)
			p->request.in_param = NULL;
		else {
			if (net2_cp_init_alloc(c, args, &p->request.in_param,
			    NULL))
				goto request_fail_init;
			if (net2_cp_decode(c, args, p->request.in_param, in,
			    NULL))
				goto request_fail_decode;
		}

		/* Fully decoded. */
		break;

	case OBJMAN_PH_IS_SUPERSEDE >> OBJMAN_PH_IS_MASK_SHIFT:
		if (net2_cp_decode(c, &cp_net2_objman_supersede, &p->supersede,
		    in, NULL))
			return -1;
		break;

	case OBJMAN_PH_IS_RESPONSE >> OBJMAN_PH_IS_MASK_SHIFT:
		if (net2_cp_decode(c, &cp_net2_objman_response,
		    &p->response, in, &p->mh))
			return -1;

		return -1;	/* TODO: implement */

	case OBJMAN_PH_IS_OBJMAN >> OBJMAN_PH_IS_MASK_SHIFT:
		return -1;	/* TODO: implement */

	default:
		/* Message not recognized. */
		return -1;
	}

	return 0;


	/*
	 * Failure cleanup for OBJMAN_PH_IS_REQUEST case.
	 */
request_fail_decode:
	net2_cp_destroy_alloc(c, args, &p->request.in_param, NULL);
request_fail_init:
	return -1;
}


static int
n2om_resp_init(struct net2_encdec_ctx *c, struct net2_objman_response *r,
    const struct net2_objman_proto_header *h)
{
	r->result_type = NULL;
	r->result = NULL;
	return 0;
}

static int
n2om_resp_destroy(struct net2_encdec_ctx *c, struct net2_objman_response *r,
    const struct net2_objman_proto_header *h)
{
	if (r->result) {
		if (r->result_type == NULL)
			return -1;
		if (net2_cp_destroy_alloc(c, r->result_type, &r->result, NULL))
			return -1;
	}
	return 0;
}

static int
n2om_resp_encode(struct net2_encdec_ctx *c, struct net2_buffer *out,
    const struct net2_objman_response *r,
    const struct net2_objman_proto_header *h)
{
	int	err;
	int	fin_how;

	fin_how = (h->flags & OBJMANRESP_PH_FINSTATE);

	/* Handle sequence and group. */
	if ((err = net2_cp_encode(c, &cp_uint32, out, &r->seq, NULL)) != 0)
		return err;
	if ((err = net2_cp_encode(c, &cp_uint32, out, &r->group, NULL)) != 0)
		return err;

	switch (fin_how) {
	case NET2_IVCTX_FIN_ERROR:
		/* Handle error code. */
		if ((err = net2_cp_encode(c, &cp_uint32, out, &r->error, NULL)) != 0)
			return err;
		break;
	case NET2_IVCTX_FIN_OK:
		if (r->result_type != NULL &&
		    (err = net2_cp_encode(c, r->result_type, out, r->result, NULL)) != 0)
			return err;
		break;
	}

	return 0;
}

static int
n2om_resp_decode(struct net2_encdec_ctx *c, struct net2_objman_response *r,
    struct net2_buffer *in,
    const struct net2_objman_proto_header *h)
{
	int	err;
	int	fin_how;

	fin_how = (h->flags & OBJMANRESP_PH_FINSTATE);

	/* Handle sequence and group. */
	if ((err = net2_cp_decode(c, &cp_uint32, &r->seq, in, NULL)) != 0)
		return err;
	if ((err = net2_cp_decode(c, &cp_uint32, &r->group, in, NULL)) != 0)
		return err;

	switch (fin_how) {
	case NET2_IVCTX_FIN_ERROR:
		/* Handle error code. */
		if ((err = net2_cp_decode(c, &cp_uint32, &r->error, in, NULL)) != 0)
			return err;
		break;
	case NET2_IVCTX_FIN_OK:
		r->result_type = ... /* lookup type in c. */

		if (r->result_type != NULL) {
			if ((err = net2_cp_init_alloc(c, r->result_type,
			    &r->result, NULL)) != 0)
				return err;
			if ((err = net2_cp_decode(c, r->result_type, r->result,
			    in, NULL)) != 0) {
				net2_cp_destroy_alloc(c, r->result_type,
				    &r->result, NULL);
				return err;
			}
		}
		break;
	}

	return 0;
}
