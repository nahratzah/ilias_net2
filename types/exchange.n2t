/*
 * Copyright (c) 2012 Ariane van der Steldt <ariane@stack.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <ilias/net2/buffer.h>
#include "signature.h"
#include <sys/types.h>
#include <stdint.h>

/*
 * Format on the wire, of exchange messages.
 */
struct exchange_msg {
	uint8_t				 slot;
	uint8_t				 msg_id;
#define XMSG_SIGNATURE			0x80
#define XMSG_SETUP			0x00
#define XMSG_INITBUF			0x01
#define XMSG_RESPONSE			0x02

	uint16_t			 padding;
	union {
		/* Setup of exchange. */
		struct {
			char		*exchange_alg;
			char		*result_alg;
		};

		/* Buffer transfer. */
		struct {
			uint16_t	 offset;
			uint16_t	 total_len;
			struct net2_buffer
					*data;
		};

		/* Signature. */
		struct {
			uint32_t	 signature_idx;
			struct net2_signature
					 signature;
		};
	}				 payload;
};

ILIAS_NET2_LOCAL
int	 mk_exchange_msg_setup(struct exchange_msg*, int, int, int,
	    const char*(*)(int));
ILIAS_NET2_LOCAL
int	 mk_exchange_msg_buf(struct exchange_msg*, int, int,
	    struct net2_buffer*, size_t, size_t);

%%
#include "exchange.h"
#include <string.h>
#include <ilias/net2/ctypes.h>
#include <ilias/net2/xchange.h>
#include <ilias/net2/memory.h>
#include <ilias/net2/conn_negotiator.h>	/* For NET2_CNEG_S2_MAX define. */

%%

type exchange_msg (ctype struct exchange_msg,
    init exchange_msg_init,
    destroy exchange_msg_destroy,
    encode exchange_msg_encode,
    decode exchange_msg_decode);

struct exchange_msg__shared (ctype struct exchange_msg,
    init NULL,
    destroy NULL,
    protocol net2_proto) {
	uint8			slot;
	uint8			msg_id;
	uint16			padding;
};

struct exchange_msg__setup (ctype struct exchange_msg,
    init NULL,
    protocol net2_proto) {
	paddedstring		payload.exchange_alg;
	paddedstring		payload.result_alg;
};

struct exchange_msg__transfer (ctype struct exchange_msg,
    init NULL,
    protocol net2_proto) {
	uint16			payload.offset;
	uint16			payload.total_len;
	short_net2_buffer	payload.data;
};

struct exchange_msg__signature (ctype struct exchange_msg,
    init NULL,
    protocol net2_proto) {
	uint32			payload.signature_idx;
	net2_signature		payload.signature;
};

%%

static __inline const struct command_param*
get_exchange_cp(const struct exchange_msg *msg)
{
	if (msg->slot >= NET2_CNEG_S2_MAX)
		return NULL;	/* Only first 4 slots are currently defined. */

	if (msg->msg_id & XMSG_SIGNATURE)
		return &cp_exchange_msg__signature;

	switch (msg->msg_id) {
	case XMSG_SETUP:
		return &cp_exchange_msg__setup;
	case XMSG_INITBUF:
	case XMSG_RESPONSE:
		return &cp_exchange_msg__transfer;
	default:
		return NULL;
	}
}

static int
exchange_msg_init(struct net2_encdec_ctx *c, struct exchange_msg *msg,
    const void *arg)
{
	memset(msg, 0, sizeof(*msg));
	return 0;
}
static int
exchange_msg_destroy(struct net2_encdec_ctx *c, struct exchange_msg *msg,
    const void *arg)
{
	const struct command_param
				*cp;

	if ((cp = get_exchange_cp(msg)) == NULL)
		return EINVAL;
	return net2_cp_destroy(c, cp, msg, NULL);
}
static int
exchange_msg_encode(struct net2_encdec_ctx *c, struct net2_buffer *out,
    const struct exchange_msg *msg, const void *arg)
{
	int			 error;
	const struct command_param
				*cp;

	if ((error = net2_cp_encode(c, &cp_exchange_msg__shared, out, msg,
	    NULL)) != 0)
		return error;
	if ((cp = get_exchange_cp(msg)) == NULL)
		return EINVAL;
	return net2_cp_encode(c, cp, out, msg, NULL);
}
static int
exchange_msg_decode(struct net2_encdec_ctx *c, struct exchange_msg *msg,
    struct net2_buffer *in, const void *arg)
{
	int			 error;
	const struct command_param
				*cp;

	if ((error = net2_cp_decode(c, &cp_exchange_msg__shared, msg, in,
	    NULL)) != 0)
		return error;
	if ((cp = get_exchange_cp(msg)) == NULL)
		return EINVAL;
	return net2_cp_decode(c, cp, msg, in, NULL);
}


/* Create setup message. */
ILIAS_NET2_LOCAL int
mk_exchange_msg_setup(struct exchange_msg *msg, int slot,
    int xchange_alg, int result_alg, const char *(*result_alg_to_name)(int))
{
	const char			*xchange_name, *result_name;

	if (msg == NULL || result_alg_to_name == NULL)
		return EINVAL;
	if (slot < 0 || slot > 0xff)
		return EINVAL;

	if ((xchange_name = net2_xchange_getname(xchange_alg)) == NULL)
		return EINVAL;
	if ((result_name = (*result_alg_to_name)(result_alg)) == NULL)
		return EINVAL;

	memset(msg, 0, sizeof(*msg));
	msg->slot = slot;
	msg->msg_id = XMSG_SETUP;

	msg->payload.exchange_alg = net2_strdup(xchange_name);
	msg->payload.result_alg = net2_strdup(result_name);
	if (msg->payload.exchange_alg == NULL ||
	    msg->payload.result_alg == NULL) {
		if (msg->payload.exchange_alg != NULL) {
			net2_free(msg->payload.exchange_alg);
			msg->payload.exchange_alg = NULL;
		}
		if (msg->payload.result_alg != NULL) {
			net2_free(msg->payload.result_alg);
			msg->payload.result_alg = NULL;
		}
		return ENOMEM;
	}

	return 0;
}

ILIAS_NET2_LOCAL int
mk_exchange_msg_buf(struct exchange_msg *msg, int slot, int msg_id,
	    struct net2_buffer *data, size_t offset, size_t len)
{
	if (slot < 0 || slot > 0xff)
		return EINVAL;
	if (data == NULL || len == 0)
		return EINVAL;

	/* Test if msg_id is a valid parameter. */
	switch (msg_id) {
	case XMSG_INITBUF:
	case XMSG_RESPONSE:
		break;
	default:
		return EINVAL;
	}

	if (offset + len < offset)
		return EINVAL;	/* Overflow. */
	if (offset + len > net2_buffer_length(data))
		return EINVAL;	/* Requested data does not exist. */
	if (offset + len > 0xffff)
		return EINVAL;	/* Only up to 64K-1 bytes data max. */


	memset(msg, 0, sizeof(*msg));
	msg->slot = slot;
	msg->msg_id = msg_id;

	msg->payload.offset = offset;
	msg->payload.total_len = len;
	if ((msg->payload.data = net2_buffer_subrange(data, offset, len)) ==
	    NULL)
		return ENOMEM;

	return 0;
}
