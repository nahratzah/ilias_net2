/*
 * Copyright (c) 2012 Ariane van der Steldt <ariane@stack.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <ilias/net2/buffer.h>
#include "signature.h"
#include <sys/types.h>
#include <stdint.h>

/*
 * Format on the wire, of exchange messages.
 */
struct exchange_msg {
	uint16_t			 slot;
#define SLOT_FIN			0xffff
	uint16_t			 msg_id;
#define XMSG_SIGNATURE			0x8000
#define XMSG_SETUP			0x0000
#define XMSG_INITBUF			0x0001
#define XMSG_RESPONSE			0x0002

	union {
		/* Setup of exchange. */
		struct {
			char		*exchange_alg;
			char		*result_alg;
		};

		/* Signature. */
		uint32_t		 signature_idx;
	}				 payload;
};

ILIAS_NET2_LOCAL
int	 mk_exchange_msg_setup(struct exchange_msg*, int, int, int,
	    const char*(*)(int));
ILIAS_NET2_LOCAL
int	 mk_exchange_msg_buf(struct exchange_msg*, int, int);
ILIAS_NET2_LOCAL
int	 mk_exchange_msg_signature(struct exchange_msg*, int, int, int);
ILIAS_NET2_LOCAL
int	 mk_exchange_msg_fin(struct exchange_msg*);
ILIAS_NET2_LOCAL
struct net2_buffer
	*exchange_signature_contents(const char*, const char*);

%%
#include "exchange.h"
#include <string.h>
#include <ilias/net2/ctypes.h>
#include <ilias/net2/xchange.h>
#include <ilias/net2/memory.h>
#include <ilias/net2/conn_negotiator.h>	/* For NET2_CNEG_S2_MAX define. */

%%

type exchange_msg (ctype struct exchange_msg,
    init exchange_msg_init,
    destroy exchange_msg_destroy,
    encode exchange_msg_encode,
    decode exchange_msg_decode);

struct exchange_msg__shared (ctype struct exchange_msg,
    init NULL,
    destroy NULL,
    protocol net2_proto) {
	uint16			slot;
	uint16			msg_id;
};

struct exchange_msg__setup (ctype struct exchange_msg,
    init NULL,
    protocol net2_proto) {
	string			payload.exchange_alg;
	string			payload.result_alg;
};

struct exchange_msg__transfer (ctype struct exchange_msg,
    init NULL,
    destroy NULL,
    protocol net2_proto) {
};

struct exchange_msg__fin (ctype struct exchange_msg,
    init NULL,
    destroy NULL,
    protocol net2_proto) {
};

struct exchange_msg__signature (ctype struct exchange_msg,
    init NULL,
    destroy NULL,
    protocol net2_proto) {
	uint32			payload.signature_idx;
};

%%

static __inline const struct command_param*
get_exchange_cp(const struct exchange_msg *msg)
{
	if (msg->slot == SLOT_FIN) {
		if (msg->msg_id != 0)
			return NULL;
		return &cp_exchange_msg__fin;
	}
	if (msg->msg_id & XMSG_SIGNATURE)
		return &cp_exchange_msg__signature;

	switch (msg->msg_id) {
	case XMSG_SETUP:
		return &cp_exchange_msg__setup;
	case XMSG_INITBUF:
	case XMSG_RESPONSE:
		return &cp_exchange_msg__transfer;
	default:
		return NULL;
	}
}

static int
exchange_msg_init(struct net2_encdec_ctx *c, struct exchange_msg *msg,
    const void *arg)
{
	memset(msg, 0, sizeof(*msg));
	return 0;
}
static int
exchange_msg_destroy(struct net2_encdec_ctx *c, struct exchange_msg *msg,
    const void *arg)
{
	const struct command_param
				*cp;

	if ((cp = get_exchange_cp(msg)) == NULL)
		return EINVAL;
	return net2_cp_destroy(c, cp, msg, NULL);
}
static int
exchange_msg_encode(struct net2_encdec_ctx *c, struct net2_buffer *out,
    const struct exchange_msg *msg, const void *arg)
{
	int			 error;
	const struct command_param
				*cp;

	if ((error = net2_cp_encode(c, &cp_exchange_msg__shared, out, msg,
	    NULL)) != 0)
		return error;
	if ((cp = get_exchange_cp(msg)) == NULL)
		return EINVAL;
	return net2_cp_encode(c, cp, out, msg, NULL);
}
static int
exchange_msg_decode(struct net2_encdec_ctx *c, struct exchange_msg *msg,
    struct net2_buffer *in, const void *arg)
{
	int			 error;
	const struct command_param
				*cp;

	if ((error = net2_cp_decode(c, &cp_exchange_msg__shared, msg, in,
	    NULL)) != 0)
		return error;
	if ((cp = get_exchange_cp(msg)) == NULL)
		return EINVAL;
	return net2_cp_decode(c, cp, msg, in, NULL);
}


/* Create setup message. */
ILIAS_NET2_LOCAL int
mk_exchange_msg_setup(struct exchange_msg *msg, int slot,
    int xchange_alg, int result_alg, const char *(*result_alg_to_name)(int))
{
	const char			*xchange_name, *result_name;

	if (msg == NULL || result_alg_to_name == NULL)
		return EINVAL;
	if (slot < 0 || slot > 0xffff)
		return EINVAL;

	if ((xchange_name = net2_xchange_getname(xchange_alg)) == NULL)
		return EINVAL;
	if ((result_name = (*result_alg_to_name)(result_alg)) == NULL)
		return EINVAL;

	memset(msg, 0, sizeof(*msg));
	msg->slot = slot;
	msg->msg_id = XMSG_SETUP;

	msg->payload.exchange_alg = net2_strdup(xchange_name);
	msg->payload.result_alg = net2_strdup(result_name);
	if (msg->payload.exchange_alg == NULL ||
	    msg->payload.result_alg == NULL) {
		if (msg->payload.exchange_alg != NULL) {
			net2_free(msg->payload.exchange_alg);
			msg->payload.exchange_alg = NULL;
		}
		if (msg->payload.result_alg != NULL) {
			net2_free(msg->payload.result_alg);
			msg->payload.result_alg = NULL;
		}
		return ENOMEM;
	}

	return 0;
}

/* Create initbuf and response messages. */
ILIAS_NET2_LOCAL int
mk_exchange_msg_buf(struct exchange_msg *msg, int slot, int msg_id)
{
	if (slot < 0 || slot > 0xffff)
		return EINVAL;

	/* Test if msg_id is a valid parameter. */
	switch (msg_id) {
	case XMSG_INITBUF:
	case XMSG_RESPONSE:
		break;
	default:
		return EINVAL;
	}

	memset(msg, 0, sizeof(*msg));
	msg->slot = slot;
	msg->msg_id = msg_id;

	return 0;
}

/* Create signature message. */
ILIAS_NET2_LOCAL int
mk_exchange_msg_signature(struct exchange_msg *msg, int slot,
    int msg_id, int sig_idx)
{
	if (slot < 0 || slot > 0xffff)
		return EINVAL;
	if (msg_id > 0x7fff)	/* High bit is reserved for XMSG_SIGNATURE. */
		return EINVAL;

	memset(msg, 0, sizeof(*msg));
	msg->slot = slot;
	msg->msg_id = msg_id | XMSG_SIGNATURE;
	msg->payload.signature_idx = sig_idx;
	return 0;
}

/* Create the final message. */
ILIAS_NET2_LOCAL int
mk_exchange_msg_fin(struct exchange_msg *msg)
{
	msg->slot = SLOT_FIN;
	msg->msg_id = 0;
	return 0;
}

/*
 * Generate the buffer over which the signature for the names must be
 * generated.
 */
ILIAS_NET2_LOCAL struct net2_buffer*
exchange_signature_contents(const char *exchange_alg,
    const char *result_alg)
{
	struct exchange_msg	 tmp;
	struct net2_buffer	*result;

	/* Must have supplied arguments. */
	if (exchange_alg == NULL || result_alg == NULL)
		return NULL;

	/* Init temporary message, used for encoding. */
	memset(&tmp, 0, sizeof(tmp));
	tmp.payload.exchange_alg = (char*)exchange_alg;
	tmp.payload.result_alg = (char*)result_alg;

	/* Create result. */
	if ((result = net2_buffer_new()) == NULL)
		return NULL;

	/* Encode temporary message into result. */
	if (net2_cp_encode(&net2_encdec_proto0, &cp_exchange_msg__setup,
	    result, &tmp, NULL))
		goto fail;

	return result;

fail:
	net2_buffer_free(result);
	return NULL;
}
